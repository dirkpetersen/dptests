#! /usr/bin/env python3

# The swim lanes at Olympic Athletic Club in Seattle are 
# insanely busy and you need to reserve half hour slots
# through a website with CAPTCHA (sic!) but at least you 
# can use Selenium to check for slots becoming available
# and notify yourself or your group via pushover, outlook
# twilio or pywahtkit

# On Linux (tested with Ubuntu) we assume we use chromium 
# and on Windows we assume we use Firefox (headless mode)
# 
# Ubuntu install:
# apt install python-selenium chromium-chromedriver

# Generated by Selenium IDE
import os, sys, hashlib, configparser
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
if sys.platform.startswith('linux'):
    from selenium.webdriver.chrome.options import Options
else:    
    from selenium.webdriver.firefox.options import Options
#from selenium.webdriver.common.action_chains import ActionChains
#from selenium.webdriver.support import expected_conditions
#from selenium.webdriver.common.keys import Keys
#from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

NO_AVAIL = "No available appointment times were found"
SWIM_URL = 'https://clients.mindbodyonline.com/asp/main_appts.asp?studioid=156942'

def main():
    # read config
    ini = os.path.expanduser('~/.config/oac-swim/oac-swim.ini')
    if not os.path.exists(ini):
        cfg = None
        print('run "notepad ~/.config/oac-swim/oac-swim.ini" to create a config file for notifications')
        messengers = None
    else:
        cfg = configparser.ConfigParser()
        cfg.read(ini)
        messengers=cfg.get('general', 'messengers', fallback=None).split(',')

    #print(messengers)

    #msg = 'Message \n Body'
    #ret = send_message_pushover(cfg, msg)

    print('checking OAC, please wait ...')
    text = check_web_table()
    print('OAC Reponse:', text)
    
    #html = remove_line_if_word_found(html,'name="CSRFToken"')
    
    # Compute MD5 of table_html
    text_md5 = compute_md5(text)
   
    write_file = True
    send_text = False
    home = os.path.expanduser("~")
    file_path = os.path.join(home, ".oac.check.txt")
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as file:
            file_content = file.read()
            file_md5 = compute_md5(file_content)            
            if file_md5 == text_md5:
                write_file = False
            else:
                print(f'New md5sum in {file_path} !')
                send_text = True        
        #if len(file_content) < len(text):  #and not NO_AVAIL in text:
        #    send_text = True
    else:
        send_text = True

    if write_file:
        # if md5sums are different 
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(text)

    #if NO_AVAIL in text:
    #    send_text = False
    #print('send_text', send_text)
    
    if not send_text:
        return True 

    for messenger in messengers:
        msg = 'Dedicated OAC Swim Slot(s):\n\n' + text + '\n' + SWIM_URL
        print(f'Sending message via {messenger} ...')
        ret = None
        if messenger == 'outlook':
            ret = send_message_outlook(cfg, msg)
        elif messenger == 'pushover':
            ret = send_message_pushover(cfg, msg)
        elif messenger == 'twilio':
            ret = send_message_twilio(cfg, msg)
        elif messenger == 'pywahtkit':
            ret = send_message_pywahtkit(cfg, msg)
        if not ret:
            print(f'Could not send message via {messenger}')

    return True

def compute_md5(content):
    # Compute MD5 hash of given content
    m = hashlib.md5()
    m.update(content.encode('utf-8'))
    return m.hexdigest()
    
def remove_line_if_word_found(text, search_word):
    lines = text.split('\n')
    # Use a list comprehension to filter out lines that contain the search word
    filtered_lines = [line for line in lines if search_word not in line]
    return '\n'.join(filtered_lines)

def kill_firefox():
    # Get the list of all running process IDs
    import psutil
    for process in psutil.process_iter():
        try:
            # Get process details as a named tuple
            pinfo = process.as_dict(attrs=['pid', 'name'])
            # Check if the process name contains "firefox"
            if "firefox" in pinfo['name'].lower():
                # Kill the process
                psutil.Process(pinfo['pid']).kill()
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass

def check_web_table():
    myoptions = Options()
    myoptions.add_argument("--headless") 
    if sys.platform.startswith('linux'):
        myoptions.add_argument('--disable-gpu')
        myoptions.add_argument('--no-sandbox')
        driver = webdriver.Chrome(options=myoptions)
    else:
        myoptions.set_preference("network.proxy.type", 0)
        driver = webdriver.Firefox(options=myoptions)
    driver.get(SWIM_URL)                
    wait = WebDriverWait(driver, 15)
    if not sys.platform.startswith('linux'):
        element = wait.until(EC.presence_of_element_located((By.ID, "tabA113")))        
    driver.find_element(By.ID, "tabA113").click()
    driver.find_element(By.LINK_TEXT, "30 minutes - Lap Swim").click()
    driver.find_element(By.NAME, "SearchButton").click()
    #self.driver.find_element(By.LINK_TEXT, "Book").click()
    #elem = self.driver.find_element(By.LINK_TEXT, "Book")
    #table = self.driver.find_element(By.CLASS_NAME, 'appointmentSearchResults')
    #table = driver.find_element(By.ID, 'table1')
    tables = driver.find_elements(By.CLASS_NAME, 'appointmentSearchResults')
    table_html = ''
    table_text = ''
    for table in tables:
        #table_html += table.get_attribute('outerHTML')
        table_text += table.text + '\n'        
    driver.quit()
    #print(table_text)
    return table_text


def send_message_twilio(cfg, msg):

    # Extract the desired values
    account_sid = cfg.get('twilio', 'account_sid', fallback=None)
    auth_token = cfg.get('twilio', 'auth_token', fallback=None)
    no_from = cfg.get('twilio', 'no_from', fallback=None)
    no_to = cfg.get('twilio', 'no_to', fallback=None)

    try:
        import twilio.rest
        tclient = twilio.rest.Client(account_sid, auth_token)
    
        message = tclient.messages.create(
            from_=no_from,      #from_=f'whatsapp:{no_from}',
            to=no_to,           #to=f'whatsapp:{no_to}',
            body=msg
        )        
        print(f'Twilio message id sent: {message.sid}')
        return True
    except Exception as e:
        print(f'Error: {e}')
        return False 

def send_message_pushover(cfg, msg):
    try:
        import http.client, urllib
        conn = http.client.HTTPSConnection("api.pushover.net:443")
        conn.request("POST", "/1/messages.json",
        urllib.parse.urlencode({
            "token": cfg.get('pushover', 'apptoken', fallback=None),
            "user": cfg.get('pushover', 'userkeys', fallback=None).split(',')[0],
            "message": msg,
        }), { "Content-type": "application/x-www-form-urlencoded" })
        ret = conn.getresponse()
        if ret.status == 200:
            print(f"Pushover message sent !")
            return True
        else:
            return False        
    except Exception as e:
        print(f'Error: {e}')
        return False 
    return True

def send_message_pywahtkit(cfg, msg):
    try:            
        import pywhatkit
        whatsapp_group_id = cfg.get('pywhatkit', 'whatsapp_group_id', fallback=None)
        pywhatkit.sendwhatmsg_to_group_instantly(whatsapp_group_id, msg)
        return True
    except Exception as e:
        print(f'Error: {e}')
        return False 

def send_message_outlook(cfg, msg):
    try:            
        import win32com.client as win32
        outlook = win32.Dispatch('outlook.application')
        namespace = outlook.GetNamespace("MAPI")
    except Exception as e:
        print(f'Error: {e}')
        return False     
    # Create a new mail item
    mail = outlook.CreateItem(0)    
    mail.Subject = msg.split('\n')[0]
    # a list of email addresses separated by semicolon
    recipients = cfg.get('outlook', 'to', fallback=None)  
    mail.To = recipients
    mail.Body = msg    
    mail.Send()
    print(f"Outlook Email sent to {recipients}.")
    return True

if __name__ == "__main__":
    if main():
        sys.exit(0)
    else:
        sys.exit(1)
