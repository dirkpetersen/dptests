#! /bin/bash

# Quickly deploy ec2 instance after answering a few questions

function prompt() {
  # usage:  prompt NEW_VAR "Prompt message" ["${PROMPT_DEFAULT_VALUE}"]
  local __resultvar=$1
  local __prompt=$2
  local __default=${3:-}
  local __result
  if [ "$ACCEPT_DEFAULTS" = true ]; then
    __result="$__default"
  else
    read -e -i "$__default" -p "$__prompt: " __result
  fi
  eval $__resultvar="'$__result'"
}

function find_instance_type() {
  local instance_types
  local filtered_types
  local query

  if [ "${GPUS}" -gt 0 ]; then
    query="InstanceTypes[?ProcessorInfo.SupportedArchitectures[?contains(@, '${ARCH}')] && to_number(VCpuInfo.DefaultVCpus) >= \`${VCPUS}\` && to_number(MemoryInfo.SizeInMiB) >= \`${MEM_MB}\` && (to_number(GpuInfo.Gpus[?Manufacturer=='NVIDIA'].Count | [0]) >= \`${GPUS}\`)]"
  else
    query="InstanceTypes[?ProcessorInfo.SupportedArchitectures[?contains(@, '${ARCH}')] && to_number(VCpuInfo.DefaultVCpus) >= \`${VCPUS}\` && to_number(MemoryInfo.SizeInMiB) >= \`${MEM_MB}\`]"
  fi

  instance_types=$(aws ec2 describe-instance-types \
    --region ${AWS_REGION} \
    --query "${query}" \
    --output json)

  # echo "Instance types found: ${instance_types}"

  filtered_types=$(echo ${instance_types} | jq -r '[.[] | select(.InstanceType | startswith("t3") or startswith("m5") or startswith("c5"))] | min_by(.VCpuInfo.DefaultVCpus).InstanceType')
  if [[ -n ${filtered_types} && ${filtered_types} != "null" ]]; then
    echo "Instance type found: ${filtered_types}"
    EC2_TYPE=${filtered_types}
  else
    echo "No suitable instance type found. Defaulting to t3.medium."
    EC2_TYPE="t3.medium"
  fi
}

function find_ami_image() {
  local images
  local query="sort_by(Images, &CreationDate)[-1].{Id:ImageId,Name:Name}"
  
  echo "Searching for AMI with OS: ${OS}, Architecture: ${ARCH}"
    
  images=$(aws ec2 describe-images \
    --region ${AWS_REGION} \
    --owners ${AMI_OWNER} \
    --filters "Name=name,Values=*${OS}*" "Name=architecture,Values=${ARCH}" \
    --query "${query}" \
    --output json)
  
  # echo "General AMI search result: ${images}"

  if [[ "${#images}" -lt 30 ]]; then 
    echo "No suitable AMI image found."
    exit 1
  elif [[ -n ${images} && ${images} != "null" ]]; then
    AMI_IMAGE=$(echo ${images} | jq -r '.Id')
    AMI_NAME=$(echo ${images} | jq -r '.Name')
    echo "AMI Image found: ${AMI_IMAGE} (${AMI_NAME})"
  else
    echo "No suitable AMI image found."
    exit 1
  fi

}

function configure_security_group() {
  # Check if the security group already exists
  existing_sg=$(aws ec2 describe-security-groups \
    --region ${AWS_REGION} \
    --filters "Name=group-name,Values=${SECURITY_GROUP}" \
    --query 'SecurityGroups[0].GroupId' \
    --output text)

  if [ "$existing_sg" != "None" ] && [ -n "$existing_sg" ]; then
    echo "Using existing security group: ${existing_sg}"
    sg_id=$existing_sg
  else
    echo "Creating new security group"
    sg_id=$(aws ec2 create-security-group \
      --region ${AWS_REGION} \
      --group-name ${SECURITY_GROUP} \
      --description "Security group for EC2 instance" \
      --query 'GroupId' --output text)

    # Add ingress rules only for newly created security group
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 22 --cidr ${IP}/32
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 80 --cidr 0.0.0.0/0
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 443 --cidr 0.0.0.0/0
  fi
}

# Define constants that can be overridden by environment variables
ACCEPT_DEFAULTS=${ACCEPT_DEFAULTS:-false}
AMI_OWNER=${AMI_OWNER:-'099720109477'}
SECURITY_GROUP=${SECURITY_GROUP:-'SSH-HTTP-ICMP'}  # ec2_cli_group default
KEY_PAIR=${KEY_PAIR:-'asm-ec2-peterdir'} # asm-ec2-peterdir key-peterdir@ohsu.edu

# User Inputs
if [ "$ACCEPT_DEFAULTS" = false ]; then
  echo -e "\n* What does your EC2 instance need?\n"
fi
prompt VCPUS "Number of VCPUs" "2"
prompt ARCH "CPU type (x86_64 or arm64)" "x86_64"
prompt MEMORY "Memory in GB" "4"
prompt EBS_SIZE "EBS Volume Size in GB" "50"
prompt EPHEMERAL_SIZE "Ephemeral Disk Size in GB" "0"
prompt GPUS "Number of NVIDIA GPUs" "0"
prompt OS "Operating System" "ubuntu-*-24.04-amd64-server"
prompt AWS_REGION "AWS Region" "us-west-2"
prompt SPOT "Spot Market (yes or no)" "no"

if [ "$ACCEPT_DEFAULTS" = true ]; then
  echo "Using default values for all inputs."
fi

VCPUS=$((VCPUS))
MEM_MB=$((MEMORY * 1024))
EBS_SIZE=$((EBS_SIZE))
EPHEMERAL_SIZE=$((EPHEMERAL_SIZE))
if [ "$EPHEMERAL_SIZE" -lt 0 ]; then
  echo "Error: Ephemeral disk size cannot be negative. Setting to 0."
  EPHEMERAL_SIZE=0
fi
GPUS=$((GPUS))

# Check AWS CLI authentication
if ! aws sts get-caller-identity &>/dev/null; then
  echo "Error: AWS CLI is not authenticated. Please run 'aws configure' or set up your credentials."
  exit 1
fi

# Instance and AMI Selection
find_instance_type
find_ami_image

# Get user's IP address
function get_user_ip() {
  IP=$(curl -s https://checkip.amazonaws.com)
  echo "Your IP address is: ${IP}"
}

# Configure Security Group and Launch EC2 Instance
get_user_ip
configure_security_group

instance_info=$(aws ec2 run-instances --region ${AWS_REGION} --image-id ${AMI_IMAGE} \
  --count 1 --instance-type ${EC2_TYPE} --key-name ${KEY_PAIR} \
  --block-device-mappings "[{\"DeviceName\":\"/dev/sda1\",\"Ebs\":{\"VolumeSize\":${EBS_SIZE}}}]" \
  $([ "$EPHEMERAL_SIZE" -gt 0 ] && echo "--block-device-mappings \"[{\\\"DeviceName\\\":\\\"/dev/sdb\\\",\\\"Ebs\\\":{\\\"VolumeSize\\\":${EPHEMERAL_SIZE},\\\"VolumeType\\\":\\\"gp2\\\"}}]\"") \
  --security-group-ids ${sg_id} --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=MyInstance}]' \
  --query 'Instances[0].InstanceId' \
  --output text)

instance_id=$instance_info

echo "Instance $instance_id is starting. Waiting for public DNS..."

# Initial delay to allow instance to initialize
sleep 10

# Wait for the instance to be in the "running" state and have a public DNS name
max_attempts=30
attempt=0
while [ $attempt -lt $max_attempts ]; do
  instance_info=$(aws ec2 describe-instances --region ${AWS_REGION} --instance-ids $instance_id \
    --query 'Reservations[0].Instances[0].{State:State.Name,PublicDnsName:PublicDnsName,InstanceType:InstanceType}' \
    --output json 2>/dev/null)
  
  if [ $? -eq 0 ]; then
    state=$(echo $instance_info | jq -r '.State')
    public_dns_name=$(echo $instance_info | jq -r '.PublicDnsName')
    instance_type=$(echo $instance_info | jq -r '.InstanceType')
    
    if [ "$state" = "running" ] && [ "$public_dns_name" != "null" ] && [ -n "$public_dns_name" ]; then
      break
    fi
  fi
  
  echo "Waiting for instance to be ready... (Attempt $((attempt+1))/$max_attempts)"
  sleep 10
  attempt=$((attempt+1))
done

if [ $attempt -eq $max_attempts ]; then
  echo "Error: Instance did not become ready within the expected time."
  exit 1
fi

echo "Starting ${public_dns_name} (${instance_id}) on ${instance_type} with ${AMI_NAME}"
echo "run: ssh -i ~/.config/asm/cloud/asm-ec2-701747442027-peterdir.pem ec2-user@${public_dns_name}"

