#!/bin/bash

# Quickly deploy ec2 instance after answering a few questions

# Define constants that can be overridden by environment variables
ACCEPT_DEFAULTS=${ACCEPT_DEFAULTS:-false}
EC2_SECURITY_GROUP=${EC2_SECURITY_GROUP:-'SSH-HTTP-ICMP'}  # ec2_cli_group default
EC2_KEY_NAME=${EC2_KEY_NAME:-'asm-ec2-peterdir'} # asm-ec2-peterdir key-peterdir@ohsu.edu
EC2_KEY_FILE=${EC2_KEY_FILE:-~/.config/asm/cloud/asm-ec2-701747442027-peterdir.pem}
AWS_REGION=${AWS_REGION:-'us-west-2'}

function list_instances() {
    aws ec2 describe-instances \
        --region ${AWS_REGION} \
        --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value | [0], InstanceId, PublicDnsName]' \
        --filters "Name=instance-state-name,Values=running" \
        --output table
}

function terminate_instance() {
    local instance_id=$1
    if aws ec2 terminate-instances --region ${AWS_REGION} --instance-ids ${instance_id}; then
        echo "Instance ${instance_id} termination request sent."
    else
        echo "Failed to terminate instance ${instance_id}."
    fi
}

function prompt() {
  # usage:  prompt NEW_VAR "Prompt message" ["${PROMPT_DEFAULT_VALUE}"]
  local __resultvar=$1
  local __prompt=$2
  local __default=${3:-}
  local __result
  if [ "$ACCEPT_DEFAULTS" = true ]; then
    __result="$__default"
  else
    read -e -i "$__default" -p "$__prompt: " __result
  fi
  eval $__resultvar="'$__result'"
}

check_aws() {
  if ! command -v aws >/dev/null 2>&1; then
    echo "AWS CLI is not installed. Installing..."
    tmpdir=$(mktemp -d -t awscli-XXX)

    # Download, unzip, and install AWS CLI v2 using full paths
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "$tmpdir/awscliv2.zip" \
      && unzip "$tmpdir/awscliv2.zip" -d "$tmpdir" \
      && "$tmpdir/aws/install" -i ~/.local/share/aws-cli -b ~/.local/bin
     # Clean up by removing the temporary directory
    rm -rf "$tmpdir"
    export PATH=~/.local/bin:$PATH
  fi
  
  # Check AWS CLI authentication
  if ! aws sts get-caller-identity &>/dev/null; then
    echo "Error: AWS CLI is not authenticated. Please run 'aws sso login --no-browser' or set up your credentials."
    exit 1
  fi

}


# Function to set EC2_USER and EC2_AMI_OWNER based on AMI_NAME
function set_ec2_user_and_owner() {
  local os_lower=$(echo "$OS" | tr '[:upper:]' '[:lower:]')
  if [[ $os_lower == *"al202"* ]]; then
    EC2_USER="ec2-user"
    EC2_AMI_OWNER="137112412989"
  elif [[ $os_lower == *"ubuntu"* ]]; then
    EC2_USER="ubuntu"
    EC2_AMI_OWNER="099720109477" 
  elif [[ $os_lower == *"rocky"* ]]; then
    EC2_USER="rocky"
    EC2_AMI_OWNER="792107900819" # Rocky's owner ID
  else
    echo "Error: Unsupported AMI name. Please use 'Amazon Linux' ,'Ubuntu' or 'Rocky'"
    exit 1
  fi
}

function find_instance_type() {
  local instance_types
  local filtered_types
  local query

  # Base query for CPU and Memory
  query="InstanceTypes[?to_number(VCpuInfo.DefaultVCpus) >= \`${VCPUS}\` && to_number(MemoryInfo.SizeInMiB) >= \`${MEM_MB}\`"

  # Add CPU architecture if needed
  if [[ "${ARCH}" == "x86" || "${ARCH}" == "amd64" ]]; then ARCH="x86_64"; fi
  if [[ "${ARCH}" == "arm" || "${ARCH}" == "graviton" ]]; then ARCH="arm64"; fi
    
  if [[ "${ARCH}" == "arm64" || "${ARCH}" == "x86_64" ]]; then
    query="${query} && ProcessorInfo.SupportedArchitectures[?contains(@, '${ARCH}')]"
  fi

  # Add GPU requirement if needed
  if [ "${GPUS}" -gt 0 ]; then
    if [ "$GPU_MODEL" = "any" ]; then
      query="${query} && (to_number(GpuInfo.Gpus[?Manufacturer=='NVIDIA'].Count | [0]) >= \`${GPUS}\`) && (to_number(GpuInfo.Gpus[?Manufacturer=='NVIDIA'].MemoryInfo.SizeInMiB | [0]) >= \`$((GPU_VRAM * 1024))\`)"
    else
      query="${query} && (to_number(GpuInfo.Gpus[?Manufacturer=='NVIDIA' && Name=='${GPU_MODEL}'].Count | [0]) >= \`${GPUS}\`)"
    fi
  fi

  # Add ephemeral disk requirement if needed
  if [ "${EPHEMERAL_SIZE}" -gt 0 ]; then    
    query="${query} && (not_null(InstanceStorageInfo) && InstanceStorageInfo.TotalSizeInGB >= \`${EPHEMERAL_SIZE}\`)"
  fi

  # Close last bracket
  query="${query}]"

  echo "$query" > ec2_query.txt
  # exit 1

  instance_types=$(aws ec2 describe-instance-types \
    --region ${AWS_REGION} \
    --query "${query}" \
    --output json)

  echo "$instance_types" > ec2_instance_types.json 

  if [ -z "$instance_types" ] || [ "$instance_types" == "[]" ]; then
    echo "No instance types found matching the criteria. Defaulting to t3.small."
    EC2_TYPE="t3.small"
  else
    # Sort by vCPUs (ascending), then by memory (ascending), then by price (ascending)
    if [[ "${GPUS}" -gt 0 ]]; then
      filtered_types=$(echo ${instance_types} | jq -r 'sort_by(.VCpuInfo.DefaultVCpus, .MemoryInfo.SizeInMiB) | map(select(.GpuInfo.Gpus != null)) | sort_by(.GpuInfo.Gpus[0].MemoryInfo.SizeInMiB) | .[0].InstanceType // empty')
    else
      filtered_types=$(echo ${instance_types} | jq -r 'sort_by(.VCpuInfo.DefaultVCpus, .MemoryInfo.SizeInMiB) | .[0].InstanceType // empty')
    fi
    
    if [[ -n ${filtered_types} ]]; then
      echo "Instance type found: ${filtered_types}"
      EC2_TYPE=${filtered_types}
    else
      echo "No suitable instance type found after filtering. Defaulting to t3.small."
      EC2_TYPE="t3.small"
    fi
  fi

  # Query additional information about the selected instance type
  instance_info=$(aws ec2 describe-instance-types --instance-types ${EC2_TYPE} --query 'InstanceTypes[0]' --output json)
  vcpus=$(echo $instance_info | jq -r '.VCpuInfo.DefaultVCpus')
  memory=$(echo $instance_info | jq -r '.MemoryInfo.SizeInMiB')
  memory_gb=$(awk "BEGIN {printf \"%.1f\", $memory/1024}")
  ephemeral=$(echo $instance_info | jq -r '.InstanceStorageInfo.TotalSizeInGB // 0')
  gpu_info=$(echo $instance_info | jq -r '.GpuInfo.Gpus[0].Name // "N/A"')
  gpu_vram=$(echo $instance_info | jq -r '.GpuInfo.Gpus[0].MemoryInfo.SizeInMiB // 0')
  gpu_vram_gb=$(awk "BEGIN {printf \"%.1f\", $gpu_vram/1024}")

  # Get the hourly on-demand price from us-east-1
  price_info=$(aws pricing get-products --region us-east-1 --service-code AmazonEC2 --filters "Type=TERM_MATCH,Field=instanceType,Value=${EC2_TYPE}" "Type=TERM_MATCH,Field=operatingSystem,Value=Linux" "Type=TERM_MATCH,Field=preInstalledSw,Value=NA" "Type=TERM_MATCH,Field=regionCode,Value=${AWS_REGION}" --max-results 1 --output json)
  price=$(echo $price_info | jq -r '.PriceList[0] | fromjson | .terms.OnDemand[].priceDimensions[].pricePerUnit.USD')

  if [ -z "$price" ]; then
    price="N/A"
  else
    price=$(printf "%.4f" $price)
  fi

  echo "Selected instance type: ${EC2_TYPE} (vCPUs: ${vcpus}, Memory: ${memory_gb} GB, Ephemeral: ${ephemeral} GB, GPU: ${gpu_info} (${gpu_vram_gb} GB VRAM), Price: \$${price}/hour)"

  exit

}

function find_ami_image() {
  local images
  local query="sort_by(Images, &CreationDate)[-1].{Id:ImageId,Name:Name}"
  
  echo "Searching for AMI with OS: ${OS}, Architecture: ${ARCH}"
    
  images=$(aws ec2 describe-images \
    --region ${AWS_REGION} \
    --owners ${EC2_AMI_OWNER} \
    --filters "Name=name,Values=${OS}" "Name=architecture,Values=${ARCH}" \
    --query "${query}" \
    --output json)

  # echo "aws ec2 describe-images --region ${AWS_REGION} --owners ${EC2_AMI_OWNER} --filters \"Name=name,Values=*${OS}*\" \"Name=architecture,Values=${ARCH}\" --query \"${query}\" --output json"
  # echo "General AMI search result: ${images}"

  if [[ "${#images}" -lt 30 ]]; then 
    echo "No suitable AMI image found."
    exit 1
  elif [[ -n ${images} && ${images} != "null" ]]; then
    AMI_IMAGE=$(echo ${images} | jq -r '.Id')
    AMI_NAME=$(echo ${images} | jq -r '.Name')
    echo "AMI Image found: ${AMI_IMAGE} (${AMI_NAME})"
  else
    echo "No suitable AMI image found."
    exit 1
  fi

}

# Get user's IP address
function get_user_ip() {
  IP=$(curl -s https://checkip.amazonaws.com)
  echo "Your IP address is: ${IP}"
}

function configure_security_group() {
  # Check if the security group already exists
  existing_sg=$(aws ec2 describe-security-groups \
    --region ${AWS_REGION} \
    --filters "Name=group-name,Values=${EC2_SECURITY_GROUP}" \
    --query 'SecurityGroups[0].GroupId' \
    --output text)

  if [ "$existing_sg" != "None" ] && [ -n "$existing_sg" ]; then
    echo "Using existing security group: ${existing_sg}"
    sg_id=$existing_sg
  else
    echo "Creating new security group"
    sg_id=$(aws ec2 create-security-group \
      --region ${AWS_REGION} \
      --group-name ${EC2_SECURITY_GROUP} \
      --description "Security group for EC2 instance" \
      --query 'GroupId' --output text)

    # Add ingress rules only for newly created security group
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 22 --cidr ${IP}/32
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 80 --cidr 0.0.0.0/0
    aws ec2 authorize-security-group-ingress --region ${AWS_REGION} \
      --group-id ${sg_id} --protocol tcp --port 443 --cidr 0.0.0.0/0
  fi
}

launch_instance() {
  # Check for cloud-init.txt file
  cloud_init_file="cloud-init.txt"
  if [ -f "./${cloud_init_file}" ]; then
    cloud_init_path="${cloud_init_file}"
  elif [ -f "$(dirname "$0")/${cloud_init_file}" ]; then
    cloud_init_path="$(dirname "$0")/${cloud_init_file}"
  fi
  # base64file=$(mktemp)
  # base64 < ${cloud_init_path} > ${base64file}
  # If cloud-init.txt exists, use it
  userdata=""
  if [[ -n "$cloud_init_path" ]]; then  
    userdata="--user-data file://${cloud_init_path}"
    echo "Using cloud-init script from $cloud_init_path"
  fi
  # Configure Security Group and Launch EC2 Instance

  # construct block device mapping JSON
  BLK_DEV_JSON="["
  if [[ $EBS_SIZE -gt 0 ]]; then
      BLK_DEV_JSON+="{\"DeviceName\":\"/dev/sda1\",\"Ebs\":{\"VolumeSize\":${EBS_SIZE}}}"
  fi
  if [[ $EPHEMERAL_SIZE -gt 0 ]]; then
      [[ $EBS_SIZE -gt 0 ]] && BLK_DEV_JSON+=","
      BLK_DEV_JSON+="{\"DeviceName\":\"/dev/sdb\",\"VirtualName\":\"ephemeral0\"}"
  fi
  BLK_DEV_JSON+="]"

  # x="aws ec2 run-instances --region ${AWS_REGION} --image-id ${AMI_IMAGE} \
    # --count 1 --instance-type ${EC2_TYPE} --key-name ${EC2_KEY_NAME} \
    # --security-group-ids ${sg_id} --block-device-mappings "${BLK_DEV_JSON}" ${userdata} \
    # --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${NAME}}]" \
    # --query 'Instances[0].InstanceId' --output text
  #   "

  # printf "Running: $x\n"

  #exit 1

  INSTANCE_INFO=$(
    aws ec2 run-instances --region ${AWS_REGION} --image-id ${AMI_IMAGE} \
    --count 1 --instance-type ${EC2_TYPE} --key-name ${EC2_KEY_NAME} \
    --security-group-ids ${sg_id} --block-device-mappings "${BLK_DEV_JSON}" ${userdata} \
    --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${NAME}}]" \
    --query 'Instances[0].InstanceId' --output text
    )
}

#########################################################################################################
# Main script

check_aws

# Retrieve GPU models early
GPU_MODELS=$(aws ec2 describe-instance-types --query 'InstanceTypes[*].GpuInfo.Gpus[?Manufacturer==`NVIDIA`].Name' --output json | jq -r 'flatten | unique | join(",")')

# Check for command line arguments
if [ "$1" = "list" ]; then
    list_instances
    exit 0
elif [ "$1" = "term" ]; then
    if [ -z "$2" ]; then
        echo "Error: Instance ID is required for termination."
        echo "Usage: $0 term <instance-id>"
        exit 1
    fi
    echo "Attempting to terminate instance $2..."
    terminate_instance "$2"
    exit 0
fi

# User Inputs
if [ "$ACCEPT_DEFAULTS" = false ]; then
  echo -e "\n* What does your EC2 instance need?\n"
fi
prompt VCPUS "Number of VCPUs" "2"
prompt ARCH "CPU type (x86, arm or any)" "any"
prompt MEMORY "Memory (GB)" "2"
prompt EBS_SIZE "EBS Volume Size (GB)" "50"
prompt EPHEMERAL_SIZE "Ephemeral (local) Disk Size (GB)" "0"
prompt GPUS "Number of NVIDIA GPUs" "0"
if [ "$GPUS" -gt 0 ]; then
  prompt GPU_MODEL "GPU Model (${GPU_MODELS} or any)" "any"
  if [ "$GPU_MODEL" = "any" ]; then
    prompt GPU_VRAM "GPU VRAM (GB)" "8"
  fi
fi
if [[ "$ACCEPT_DEFAULTS" = false ]]; then
  echo "Pick 'al202*-ami-*', '*ubuntu-*-24.04-*-server*', or 'Rocky-9-EC2-Base*':"
fi
prompt OS "Operating System" "al202*-ami-*"
prompt AWS_REGION "AWS Region" ${AWS_REGION}
prompt SPOT "Spot Market (yes or no)" "no"
prompt NAME "Instance/Host Name" "server-x"

if [ "$ACCEPT_DEFAULTS" = true ]; then
  echo ""
  echo "Using default values for all inputs:"  
  echo "VCPUS: $VCPUS"
  echo "ARCH: $ARCH"
  echo "MEMORY: $MEMORY GB"
  echo "EBS_SIZE: $EBS_SIZE GB"
  echo "EPHEMERAL_SIZE: $EPHEMERAL_SIZE GB"
  echo "GPUS: $GPUS"
  if [ "$GPUS" -gt 0 ]; then
    echo "GPU_VRAM: $GPU_VRAM GB"
  fi
  echo "OS: $OS"
  echo "AWS_REGION: $AWS_REGION"
  echo "SPOT: $SPOT"
  echo "NAME: $NAME"
  echo ""
fi

VCPUS=$((VCPUS))
MEM_MB=$((MEMORY * 1024))
EBS_SIZE=$((EBS_SIZE))
EPHEMERAL_SIZE=$((EPHEMERAL_SIZE))
if [ "$EPHEMERAL_SIZE" -lt 0 ]; then
  echo "Error: Ephemeral disk size cannot be negative. Setting to 0."
  EPHEMERAL_SIZE=0
fi
GPUS=$((GPUS))
AMI_NAME=""


# Setup required dependencies 
set_ec2_user_and_owner
find_instance_type
find_ami_image
get_user_ip
configure_security_group
launch_instance

if [ "$ACCEPT_DEFAULTS" = true ]; then
  echo "EC2_TYPE: $EC2_TYPE"
  echo "AMI_IMAGE: $AMI_IMAGE"
  echo "AMI_NAME: $AMI_NAME"
  echo "EC2_USER: $EC2_USER"  
fi


# Check if INSTANCE_INFO starts with "i-"
if [[ ${INSTANCE_INFO} == i-* ]]; then
    instance_id=${INSTANCE_INFO}
else
    echo "Error: Failed to create instance. $instance_info"
    exit 1
fi
echo "Instance $instance_id is starting. Waiting for public DNS..."

# Initial delay to allow instance to initialize
sleep 3

# Wait for the instance to be in the "running" state and have a public DNS name
max_attempts=30
attempt=0
while [ $attempt -lt $max_attempts ]; do
  instance_info=$(aws ec2 describe-instances --region ${AWS_REGION} --instance-ids $instance_id \
    --query 'Reservations[0].Instances[0].{State:State.Name,PublicDnsName:PublicDnsName,InstanceType:InstanceType}' \
    --output json 2>/dev/null)
  
  if [ $? -eq 0 ]; then
    state=$(echo $instance_info | jq -r '.State')
    public_dns_name=$(echo $instance_info | jq -r '.PublicDnsName')
    instance_type=$(echo $instance_info | jq -r '.InstanceType')
    
    if [ "$state" = "running" ] && [ "$public_dns_name" != "null" ] && [ -n "$public_dns_name" ]; then
      break
    fi
  fi
  
  echo "Waiting for instance to be ready... (Attempt $((attempt+1))/$max_attempts)"
  sleep 10
  attempt=$((attempt+1))
done

if [ $attempt -eq $max_attempts ]; then
  echo "Error: Instance did not become ready within the expected time."
  exit 1
fi

echo "Starting ${public_dns_name} (${instance_id}) on ${instance_type} with ${AMI_NAME}"
echo -e "\nRun this SSH command to connect:"
history -a
echo "ssh -i ${EC2_KEY_FILE} ${EC2_USER}@${public_dns_name}" | tee -a ~/.bash_history
history -r
echo -e "\nWaiting for SSH to become available..."

# Wait for SSH to become available
max_ssh_attempts=30
ssh_attempt=0
while [ $ssh_attempt -lt $max_ssh_attempts ]; do
  if ssh -i "${EC2_KEY_FILE}" -o ConnectTimeout=3 -o BatchMode=yes -o StrictHostKeyChecking=no ${EC2_USER}@${public_dns_name} exit 2>/dev/null; then # 2>/dev/null
    echo "SSH is now available."
    break
  fi
  echo "Waiting for SSH... (Attempt $((ssh_attempt+1))/$max_ssh_attempts)"
  sleep 5
  ssh_attempt=$((ssh_attempt+1))
done

if [ $ssh_attempt -eq $max_ssh_attempts ]; then
  echo "Error: SSH did not become available within the expected time."
  exit 1
fi
alias ssh='ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
ssh -i ${EC2_KEY_FILE} ${EC2_USER}@${public_dns_name}
