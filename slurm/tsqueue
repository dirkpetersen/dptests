#!/usr/bin/env python3

import os, re, subprocess as sp, asyncio
from typing import List, Dict
from textual import events
from textual.app import App, ComposeResult
from textual.widgets import DataTable, Button, Header, Footer, Label, ProgressBar, Static, Rule
from textual.binding import Binding
from textual.containers import Vertical, Horizontal
from textual.screen import ModalScreen

class JobDetailsScreen(ModalScreen):
    DEFAULT_CSS = """
    JobDetailsScreen {
        align: center middle;
    }
    JobDetailsScreen > Vertical {
        background: $panel;
        width: 90;
        height: 90%;
        border: thick $primary;
        padding: 2 4;
    }
    JobDetailsScreen > Vertical > * {
        width: auto;
        height: auto;
    }
    JobDetailsScreen > Vertical > Label {
        padding-bottom: 2;
    }
    JobDetailsScreen > Vertical > Horizontal {
        align: right top;
        padding-bottom: 2;
    }
    JobDetailsScreen Button {
        margin-left: 0;
    }
    JobDetailsScreen .key {
        text-style: bold;
    }
    """

    def __init__(self, job_id: str, details: Dict[str, List[str]]):
        super().__init__()
        self.job_id = job_id
        self.details = details


    def compose(self) -> ComposeResult:

        #with Horizontal():
        #    yield Button("Close", id="close", variant="primary")
        #    yield Label(f"  Details for job {self.job_id}", id="title")            

        with Vertical(): 
            # Scrollable DataTable for details
            with Horizontal():
                yield Button("Close", id="close", variant="primary")
                yield Label(f"  Details for job {self.job_id}", id="title")
            details_table = DataTable()
            details_table.zebra_stripes = True
            details_table.cursor_type = "none"
            details_table.styles.max_height = "99vh"
            details_table.add_column("Key", width=20)
            details_table.add_column("Value") 
            for key, values in self.details.items():
                for value in values:
                    if value not in [None, '']:
                        details_table.add_row(key, value) 
            yield details_table  

    def on_button_pressed(self, event: Button.Pressed) -> None:
        self.dismiss()



class TSQueue(App):
    BINDINGS = [
        ("q", "request_quit", "Quit"),
    ]

    def compose(self) -> ComposeResult:
        table = DataTable()
        table.focus()
        table.zebra_stripes = True
        table.cursor_type = "row"
        table.styles.max_height = "99vh"
        yield table

    def on_mount(self) -> None:
        self.data_table = self.query_one(DataTable)
        self.update_data()

    def update_data(self) -> None:
        columns, data = self.get_squeue_data()
        self.data_table.add_columns(*columns)
        self.data_table.add_rows(data)

    def get_squeue_data(self) -> tuple[List[str], List[List[str]]]:
        squeue_format = os.getenv('SQUEUE_FORMAT', '%.18i %.4P %.12j %.8u %.2t %.10M %.10L %.3D %.3C %.9b %.4m %R')
        cmd = f'squeue --format="{squeue_format}"'
        output = sp.check_output(cmd, shell=True, text=True)
        lines = output.strip().split('\n')
        columns = re.split(r'\s+', lines[0].strip())
        data = [re.split(r'\s+', line.strip()) for line in lines[1:]]
        return columns, data

    async def get_job_details(self, job_id: str) -> Dict[str, List[str]]:

        user = os.getlogin()  # Get the current username

        # Attempt to use sstat first
        cmd = f'sstat -j {job_id} -a -P'
        process = await asyncio.create_subprocess_shell(cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
        stdout, stderr = await process.communicate()

        # Check if sstat indicated an error (assuming it would mention 'Invalid user')
        if "Invalid user id" in stderr.decode():
            # Fallback to sacct since it likely wasn't your job
            cmd = f'sacct -j {job_id} -l -P -X'
            process = await asyncio.create_subprocess_shell(cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            stdout, stderr = await process.communicate()

        lines = stdout.decode().strip().split('\n')
        details = {}
        keys = lines[0].split('|')
        values = [line.split('|') for line in lines[1:]]
        for i, key in enumerate(keys):
            details[key] = [value[i] for value in values]
        print("Job Details:")
        print(details)
        return details

    async def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
        job_id = self.data_table.get_row(event.row_key)[0]
        details = await self.get_job_details(job_id)
        screen = JobDetailsScreen(job_id, details)
        await self.push_screen(screen)

    def action_request_quit(self) -> None:
        self.app.exit()

if __name__ == '__main__':
    TSQueue().run()
